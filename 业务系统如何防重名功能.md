### 业务系统如何正确实现防重名功能

在业务系统中防重名是一个非常普遍的需求，例如用户注册时不允许用户名重复、已登录用户不可以在自己的账号范围内创建同名的某种实体等。

```java
public void register(User user) {
    // 判断是否重复 (1)
    if (userMapper.selectExist(user.getUsername())) {
        // 报错
        throw new XXXException();
    }

    // 执行注册 (2)
    userMapper.insertSelective(xxxModel);
}
```

假设有A、B两个用户都使用了同一个叫作"bruce"的用户名，且恰好"同时"点击了注册按钮，请求也恰好"同时"
到达服务器。这时候你的web服务会启动两条线程来处理这两个请求，于是A, B同时执行数据库查询 (1)
来判断是否重名，因为此时表中还不存在username列为bruce的行，所以A, B都会顺利通过检查，然后各自插入一条记录，从而导致用户名重复。

如何解决？在数据库层面，最简单的就是给username字段加**唯一约束**，这是最笨的方式，但唯一约束会严重制约扩展能力(
读写分离、分库分表)，同时降低系统的健壮性(通过数据库报错来反馈业务错误信息)。所以这种业务问题根本就不是DB层应该考虑的事情。
问题抛给业务层，我们需要**分布式锁**。此外还要要注意你不能简单粗暴的把整个注册逻辑用一把锁给锁了，那样会严重降低系统的吞吐量，不可取。想在问题被拆分成了两个，
**如何实现分布式锁** +
**如何尽量减少锁的粒度**。

### 正确实现Redis锁 && 降低锁粒度

具体方法：

**判断key是否存在跟创建key(锁)要原子性完成。**

Redis中要想原子性有三种方式，一是利用Redis的单线程特性想办法用一条指令完成任务，如setnx；二是使用Pipeline连续执行多条命令；三是执行lua脚本。显然第一种方法最简单。

```shell
    // null 表示已经存在
    String ret = cmd.set(key, val, 'nx', 'ex', expireSecond);
```

这个方法能同时完成：

* 判断key是否存在，存在返回null
* 创建key, 设置成指定值
* 指定过期时间

那么问题来了，key和value应该设置成啥才好？这里是要分场景的。

如果你是在做一把全局锁让多个实例都来争抢的话，那么key应该设置成一个固定的值，value设置成一个随机数(nonce)
。在释放锁的时候，程序要先判断当前redis里key的value值是不是自己之前设置的nonce,
如果是才能安全的删除key，否则就啥也不干。这是为了防止某个实例因为业务逻辑处理超时而导致意外的释放了别人的锁。我们来分析一下，假如key的过期时间是5s,
然后你在某次执行过程中用了10s才完成处理，那么此时锁有可能会被被人给抢走。如果你在10s后只是简单的删除key来释放锁的话就会把别人的锁给释放了，对吧。

另一种场景是防重，比如用户注册。这种情况下不需要nonce, 即value可以忽略，但是key要设为 前缀 + 用户标识
的组合。这样做的好处是除非多个人都用了同一个用户名来注册，否则他们之间不会产生竞争，从而降低了锁的粒度。

这两种场景应该足够用了。但是这里还有其他要考虑的问题:
如果Redis不可用了怎么办？你是让程序报错等待人工干预，还是进行“降级”忽略问题？这就要看业务需求了，比如用户注册，如果系统的QPS没那么高的话，redis锁失效可以允许继续注册，因为出现重名的概率很低。无论如何一定要想着redis有连接失败的可能性，这很重要。

### 十亿用户，怎么判断新注册用户名是否重复？

大部分关系型数据库都支持B+
Tree索引，1千万个节点的树一般也就是3到5层那么高。那么n千万个节点的树是n倍高吗？不是的，只有lg（n）倍高。所以判断一个用户名，读索引次数不超过10次。考虑到索引缓存，速度是非常快的，一个判断需要几十毫秒。另一种算法是哈希索引，几乎可以达到O（1）的时间复杂度。用户名比对是精准的字符串比对，所以用哈希索引是非常合适的。合理的选择桶的数量，减少哈希碰撞的几率，能够缩短到几毫秒。考虑到网络延时，能达到十几毫秒的响应速度。如果连网络延时都嫌高，可以用Bloom
Filter方法，把10亿用户名计算得到一个Bloom
Filter数组。当有用户需要注册的时候，把这个数组送到客户端，在客户端直接判断用户名是否重复。这个数组是很小的，完全可以在网络上传输。用这个办法应该可以把延时减到10毫秒以下。但是有一定的错误率，这是Bloom
Filter算法无法避免的，所以服务端一定要做最终检查。另外还有Bitmap算法，如果你的场景是这样的：你的网站有10亿用户，他们可以随意的注销，然后再重新注册。你每个月都需要知道最近一个月注册的用户有多少是以前注册过的，你就可以使用Bitmap算法。这个算法把每个元素的存储空间降低到一个bit，所以只需要极少的内存就可以实现大集合之间的比对计算。10亿用户占用的内存只有125MB，你可以调用Redis实现Bitmap计算。