// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by protoc 25.3
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `chatmsg.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:microchat.OnlineType)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OnlineType {
    // message fields
    // @@protoc_insertion_point(field:microchat.OnlineType.device)
    pub device: ::protobuf::EnumOrUnknown<DeviceType>,
    // @@protoc_insertion_point(field:microchat.OnlineType.status)
    pub status: ::protobuf::EnumOrUnknown<OnlineStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:microchat.OnlineType.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OnlineType {
    fn default() -> &'a OnlineType {
        <OnlineType as ::protobuf::Message>::default_instance()
    }
}

impl OnlineType {
    pub fn new() -> OnlineType {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device",
            |m: &OnlineType| { &m.device },
            |m: &mut OnlineType| { &mut m.device },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &OnlineType| { &m.status },
            |m: &mut OnlineType| { &mut m.status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OnlineType>(
            "OnlineType",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OnlineType {
    const NAME: &'static str = "OnlineType";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.device = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.status = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.device != ::protobuf::EnumOrUnknown::new(DeviceType::WINDOWS) {
            my_size += ::protobuf::rt::int32_size(1, self.device.value());
        }
        if self.status != ::protobuf::EnumOrUnknown::new(OnlineStatus::OFFLINE) {
            my_size += ::protobuf::rt::int32_size(2, self.status.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.device != ::protobuf::EnumOrUnknown::new(DeviceType::WINDOWS) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.device))?;
        }
        if self.status != ::protobuf::EnumOrUnknown::new(OnlineStatus::OFFLINE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.status))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OnlineType {
        OnlineType::new()
    }

    fn clear(&mut self) {
        self.device = ::protobuf::EnumOrUnknown::new(DeviceType::WINDOWS);
        self.status = ::protobuf::EnumOrUnknown::new(OnlineStatus::OFFLINE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OnlineType {
        static instance: OnlineType = OnlineType {
            device: ::protobuf::EnumOrUnknown::from_i32(0),
            status: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OnlineType {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OnlineType").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OnlineType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnlineType {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:microchat.Header)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Header {
    // message fields
    // @@protoc_insertion_point(field:microchat.Header.compress)
    pub compress: bool,
    // @@protoc_insertion_point(field:microchat.Header.origin_size)
    pub origin_size: i32,
    // @@protoc_insertion_point(field:microchat.Header.compress_size)
    pub compress_size: i32,
    // @@protoc_insertion_point(field:microchat.Header.reserved)
    pub reserved: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:microchat.Header.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Header {
    fn default() -> &'a Header {
        <Header as ::protobuf::Message>::default_instance()
    }
}

impl Header {
    pub fn new() -> Header {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compress",
            |m: &Header| { &m.compress },
            |m: &mut Header| { &mut m.compress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "origin_size",
            |m: &Header| { &m.origin_size },
            |m: &mut Header| { &mut m.origin_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compress_size",
            |m: &Header| { &m.compress_size },
            |m: &mut Header| { &mut m.compress_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reserved",
            |m: &Header| { &m.reserved },
            |m: &mut Header| { &mut m.reserved },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Header>(
            "Header",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Header {
    const NAME: &'static str = "Header";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.compress = is.read_bool()?;
                },
                16 => {
                    self.origin_size = is.read_int32()?;
                },
                24 => {
                    self.compress_size = is.read_int32()?;
                },
                34 => {
                    self.reserved = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.compress != false {
            my_size += 1 + 1;
        }
        if self.origin_size != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.origin_size);
        }
        if self.compress_size != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.compress_size);
        }
        if let Some(v) = self.reserved.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.compress != false {
            os.write_bool(1, self.compress)?;
        }
        if self.origin_size != 0 {
            os.write_int32(2, self.origin_size)?;
        }
        if self.compress_size != 0 {
            os.write_int32(3, self.compress_size)?;
        }
        if let Some(v) = self.reserved.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Header {
        Header::new()
    }

    fn clear(&mut self) {
        self.compress = false;
        self.origin_size = 0;
        self.compress_size = 0;
        self.reserved = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Header {
        static instance: Header = Header {
            compress: false,
            origin_size: 0,
            compress_size: 0,
            reserved: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Header {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Header").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Header {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Header {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:microchat.MsgType)
pub enum MsgType {
    // @@protoc_insertion_point(enum_value:microchat.MsgType.UNKNOWN)
    UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.HEARTBEAT)
    HEARTBEAT = 1,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.REGISTER)
    REGISTER = 2,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.LOGIN)
    LOGIN = 3,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.GET_OFRIEND_LIST)
    GET_OFRIEND_LIST = 4,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.FIND_USER)
    FIND_USER = 5,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.OPERATE_FRIEND)
    OPERATE_FRIEND = 6,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.USER_STATUS_CHANGE)
    USER_STATUS_CHANGE = 7,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.UPDATE_USER_INFO)
    UPDATE_USER_INFO = 8,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.MODIFY_PASSWORD)
    MODIFY_PASSWORD = 9,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.CREATE_GROUP)
    CREATE_GROUP = 10,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.GET_GROUP_MEMBERS)
    GET_GROUP_MEMBERS = 11,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.CHAT)
    CHAT = 50,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.MULTI_CHAT)
    MULTI_CHAT = 51,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.KICK_USER)
    KICK_USER = 52,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.REMOTE_DESKTOP)
    REMOTE_DESKTOP = 53,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.UPDATE_TEAM_INFO)
    UPDATE_TEAM_INFO = 54,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.MODIFY_FRIEND_MARKNAME)
    MODIFY_FRIEND_MARKNAME = 55,
    // @@protoc_insertion_point(enum_value:microchat.MsgType.MOVE_FRIEND_TO_OTHER_TEAM)
    MOVE_FRIEND_TO_OTHER_TEAM = 56,
}

impl ::protobuf::Enum for MsgType {
    const NAME: &'static str = "MsgType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MsgType> {
        match value {
            0 => ::std::option::Option::Some(MsgType::UNKNOWN),
            1 => ::std::option::Option::Some(MsgType::HEARTBEAT),
            2 => ::std::option::Option::Some(MsgType::REGISTER),
            3 => ::std::option::Option::Some(MsgType::LOGIN),
            4 => ::std::option::Option::Some(MsgType::GET_OFRIEND_LIST),
            5 => ::std::option::Option::Some(MsgType::FIND_USER),
            6 => ::std::option::Option::Some(MsgType::OPERATE_FRIEND),
            7 => ::std::option::Option::Some(MsgType::USER_STATUS_CHANGE),
            8 => ::std::option::Option::Some(MsgType::UPDATE_USER_INFO),
            9 => ::std::option::Option::Some(MsgType::MODIFY_PASSWORD),
            10 => ::std::option::Option::Some(MsgType::CREATE_GROUP),
            11 => ::std::option::Option::Some(MsgType::GET_GROUP_MEMBERS),
            50 => ::std::option::Option::Some(MsgType::CHAT),
            51 => ::std::option::Option::Some(MsgType::MULTI_CHAT),
            52 => ::std::option::Option::Some(MsgType::KICK_USER),
            53 => ::std::option::Option::Some(MsgType::REMOTE_DESKTOP),
            54 => ::std::option::Option::Some(MsgType::UPDATE_TEAM_INFO),
            55 => ::std::option::Option::Some(MsgType::MODIFY_FRIEND_MARKNAME),
            56 => ::std::option::Option::Some(MsgType::MOVE_FRIEND_TO_OTHER_TEAM),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MsgType> {
        match str {
            "UNKNOWN" => ::std::option::Option::Some(MsgType::UNKNOWN),
            "HEARTBEAT" => ::std::option::Option::Some(MsgType::HEARTBEAT),
            "REGISTER" => ::std::option::Option::Some(MsgType::REGISTER),
            "LOGIN" => ::std::option::Option::Some(MsgType::LOGIN),
            "GET_OFRIEND_LIST" => ::std::option::Option::Some(MsgType::GET_OFRIEND_LIST),
            "FIND_USER" => ::std::option::Option::Some(MsgType::FIND_USER),
            "OPERATE_FRIEND" => ::std::option::Option::Some(MsgType::OPERATE_FRIEND),
            "USER_STATUS_CHANGE" => ::std::option::Option::Some(MsgType::USER_STATUS_CHANGE),
            "UPDATE_USER_INFO" => ::std::option::Option::Some(MsgType::UPDATE_USER_INFO),
            "MODIFY_PASSWORD" => ::std::option::Option::Some(MsgType::MODIFY_PASSWORD),
            "CREATE_GROUP" => ::std::option::Option::Some(MsgType::CREATE_GROUP),
            "GET_GROUP_MEMBERS" => ::std::option::Option::Some(MsgType::GET_GROUP_MEMBERS),
            "CHAT" => ::std::option::Option::Some(MsgType::CHAT),
            "MULTI_CHAT" => ::std::option::Option::Some(MsgType::MULTI_CHAT),
            "KICK_USER" => ::std::option::Option::Some(MsgType::KICK_USER),
            "REMOTE_DESKTOP" => ::std::option::Option::Some(MsgType::REMOTE_DESKTOP),
            "UPDATE_TEAM_INFO" => ::std::option::Option::Some(MsgType::UPDATE_TEAM_INFO),
            "MODIFY_FRIEND_MARKNAME" => ::std::option::Option::Some(MsgType::MODIFY_FRIEND_MARKNAME),
            "MOVE_FRIEND_TO_OTHER_TEAM" => ::std::option::Option::Some(MsgType::MOVE_FRIEND_TO_OTHER_TEAM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MsgType] = &[
        MsgType::UNKNOWN,
        MsgType::HEARTBEAT,
        MsgType::REGISTER,
        MsgType::LOGIN,
        MsgType::GET_OFRIEND_LIST,
        MsgType::FIND_USER,
        MsgType::OPERATE_FRIEND,
        MsgType::USER_STATUS_CHANGE,
        MsgType::UPDATE_USER_INFO,
        MsgType::MODIFY_PASSWORD,
        MsgType::CREATE_GROUP,
        MsgType::GET_GROUP_MEMBERS,
        MsgType::CHAT,
        MsgType::MULTI_CHAT,
        MsgType::KICK_USER,
        MsgType::REMOTE_DESKTOP,
        MsgType::UPDATE_TEAM_INFO,
        MsgType::MODIFY_FRIEND_MARKNAME,
        MsgType::MOVE_FRIEND_TO_OTHER_TEAM,
    ];
}

impl ::protobuf::EnumFull for MsgType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MsgType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            MsgType::UNKNOWN => 0,
            MsgType::HEARTBEAT => 1,
            MsgType::REGISTER => 2,
            MsgType::LOGIN => 3,
            MsgType::GET_OFRIEND_LIST => 4,
            MsgType::FIND_USER => 5,
            MsgType::OPERATE_FRIEND => 6,
            MsgType::USER_STATUS_CHANGE => 7,
            MsgType::UPDATE_USER_INFO => 8,
            MsgType::MODIFY_PASSWORD => 9,
            MsgType::CREATE_GROUP => 10,
            MsgType::GET_GROUP_MEMBERS => 11,
            MsgType::CHAT => 12,
            MsgType::MULTI_CHAT => 13,
            MsgType::KICK_USER => 14,
            MsgType::REMOTE_DESKTOP => 15,
            MsgType::UPDATE_TEAM_INFO => 16,
            MsgType::MODIFY_FRIEND_MARKNAME => 17,
            MsgType::MOVE_FRIEND_TO_OTHER_TEAM => 18,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MsgType {
    fn default() -> Self {
        MsgType::UNKNOWN
    }
}

impl MsgType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MsgType>("MsgType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:microchat.DeviceType)
pub enum DeviceType {
    // @@protoc_insertion_point(enum_value:microchat.DeviceType.WINDOWS)
    WINDOWS = 0,
    // @@protoc_insertion_point(enum_value:microchat.DeviceType.LINUX)
    LINUX = 1,
    // @@protoc_insertion_point(enum_value:microchat.DeviceType.MAC)
    MAC = 2,
    // @@protoc_insertion_point(enum_value:microchat.DeviceType.ANDROID)
    ANDROID = 3,
    // @@protoc_insertion_point(enum_value:microchat.DeviceType.IOS)
    IOS = 4,
    // @@protoc_insertion_point(enum_value:microchat.DeviceType.IPAD)
    IPAD = 5,
}

impl ::protobuf::Enum for DeviceType {
    const NAME: &'static str = "DeviceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceType> {
        match value {
            0 => ::std::option::Option::Some(DeviceType::WINDOWS),
            1 => ::std::option::Option::Some(DeviceType::LINUX),
            2 => ::std::option::Option::Some(DeviceType::MAC),
            3 => ::std::option::Option::Some(DeviceType::ANDROID),
            4 => ::std::option::Option::Some(DeviceType::IOS),
            5 => ::std::option::Option::Some(DeviceType::IPAD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DeviceType> {
        match str {
            "WINDOWS" => ::std::option::Option::Some(DeviceType::WINDOWS),
            "LINUX" => ::std::option::Option::Some(DeviceType::LINUX),
            "MAC" => ::std::option::Option::Some(DeviceType::MAC),
            "ANDROID" => ::std::option::Option::Some(DeviceType::ANDROID),
            "IOS" => ::std::option::Option::Some(DeviceType::IOS),
            "IPAD" => ::std::option::Option::Some(DeviceType::IPAD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DeviceType] = &[
        DeviceType::WINDOWS,
        DeviceType::LINUX,
        DeviceType::MAC,
        DeviceType::ANDROID,
        DeviceType::IOS,
        DeviceType::IPAD,
    ];
}

impl ::protobuf::EnumFull for DeviceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DeviceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DeviceType {
    fn default() -> Self {
        DeviceType::WINDOWS
    }
}

impl DeviceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DeviceType>("DeviceType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:microchat.OnlineStatus)
pub enum OnlineStatus {
    // @@protoc_insertion_point(enum_value:microchat.OnlineStatus.OFFLINE)
    OFFLINE = 0,
    // @@protoc_insertion_point(enum_value:microchat.OnlineStatus.INVISIBLE)
    INVISIBLE = 1,
    // @@protoc_insertion_point(enum_value:microchat.OnlineStatus.WIFI)
    WIFI = 2,
    // @@protoc_insertion_point(enum_value:microchat.OnlineStatus.CELLULAR)
    CELLULAR = 3,
}

impl ::protobuf::Enum for OnlineStatus {
    const NAME: &'static str = "OnlineStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OnlineStatus> {
        match value {
            0 => ::std::option::Option::Some(OnlineStatus::OFFLINE),
            1 => ::std::option::Option::Some(OnlineStatus::INVISIBLE),
            2 => ::std::option::Option::Some(OnlineStatus::WIFI),
            3 => ::std::option::Option::Some(OnlineStatus::CELLULAR),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<OnlineStatus> {
        match str {
            "OFFLINE" => ::std::option::Option::Some(OnlineStatus::OFFLINE),
            "INVISIBLE" => ::std::option::Option::Some(OnlineStatus::INVISIBLE),
            "WIFI" => ::std::option::Option::Some(OnlineStatus::WIFI),
            "CELLULAR" => ::std::option::Option::Some(OnlineStatus::CELLULAR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [OnlineStatus] = &[
        OnlineStatus::OFFLINE,
        OnlineStatus::INVISIBLE,
        OnlineStatus::WIFI,
        OnlineStatus::CELLULAR,
    ];
}

impl ::protobuf::EnumFull for OnlineStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("OnlineStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for OnlineStatus {
    fn default() -> Self {
        OnlineStatus::OFFLINE
    }
}

impl OnlineStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OnlineStatus>("OnlineStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:microchat.FriendOperationType)
pub enum FriendOperationType {
    // @@protoc_insertion_point(enum_value:microchat.FriendOperationType.OPERATION_UNKNOWN)
    OPERATION_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:microchat.FriendOperationType.SEND_ADD_APPLY)
    SEND_ADD_APPLY = 1,
    // @@protoc_insertion_point(enum_value:microchat.FriendOperationType.RECV_ADD_APPLY)
    RECV_ADD_APPLY = 2,
    // @@protoc_insertion_point(enum_value:microchat.FriendOperationType.REPLY_ADD_APPLY)
    REPLY_ADD_APPLY = 3,
    // @@protoc_insertion_point(enum_value:microchat.FriendOperationType.SEND_DELETE_APPLY)
    SEND_DELETE_APPLY = 4,
    // @@protoc_insertion_point(enum_value:microchat.FriendOperationType.RECV_DELETE_APPLY)
    RECV_DELETE_APPLY = 5,
}

impl ::protobuf::Enum for FriendOperationType {
    const NAME: &'static str = "FriendOperationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FriendOperationType> {
        match value {
            0 => ::std::option::Option::Some(FriendOperationType::OPERATION_UNKNOWN),
            1 => ::std::option::Option::Some(FriendOperationType::SEND_ADD_APPLY),
            2 => ::std::option::Option::Some(FriendOperationType::RECV_ADD_APPLY),
            3 => ::std::option::Option::Some(FriendOperationType::REPLY_ADD_APPLY),
            4 => ::std::option::Option::Some(FriendOperationType::SEND_DELETE_APPLY),
            5 => ::std::option::Option::Some(FriendOperationType::RECV_DELETE_APPLY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FriendOperationType> {
        match str {
            "OPERATION_UNKNOWN" => ::std::option::Option::Some(FriendOperationType::OPERATION_UNKNOWN),
            "SEND_ADD_APPLY" => ::std::option::Option::Some(FriendOperationType::SEND_ADD_APPLY),
            "RECV_ADD_APPLY" => ::std::option::Option::Some(FriendOperationType::RECV_ADD_APPLY),
            "REPLY_ADD_APPLY" => ::std::option::Option::Some(FriendOperationType::REPLY_ADD_APPLY),
            "SEND_DELETE_APPLY" => ::std::option::Option::Some(FriendOperationType::SEND_DELETE_APPLY),
            "RECV_DELETE_APPLY" => ::std::option::Option::Some(FriendOperationType::RECV_DELETE_APPLY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FriendOperationType] = &[
        FriendOperationType::OPERATION_UNKNOWN,
        FriendOperationType::SEND_ADD_APPLY,
        FriendOperationType::RECV_ADD_APPLY,
        FriendOperationType::REPLY_ADD_APPLY,
        FriendOperationType::SEND_DELETE_APPLY,
        FriendOperationType::RECV_DELETE_APPLY,
    ];
}

impl ::protobuf::EnumFull for FriendOperationType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FriendOperationType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FriendOperationType {
    fn default() -> Self {
        FriendOperationType::OPERATION_UNKNOWN
    }
}

impl FriendOperationType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FriendOperationType>("FriendOperationType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:microchat.friendOperationApplyType)
pub enum FriendOperationApplyType {
    // @@protoc_insertion_point(enum_value:microchat.friendOperationApplyType.APPLY_UNKNOWN)
    APPLY_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:microchat.friendOperationApplyType.APPLY_REFUSED)
    APPLY_REFUSED = 1,
    // @@protoc_insertion_point(enum_value:microchat.friendOperationApplyType.APPLY_ACCEPTED)
    APPLY_ACCEPTED = 2,
}

impl ::protobuf::Enum for FriendOperationApplyType {
    const NAME: &'static str = "friendOperationApplyType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FriendOperationApplyType> {
        match value {
            0 => ::std::option::Option::Some(FriendOperationApplyType::APPLY_UNKNOWN),
            1 => ::std::option::Option::Some(FriendOperationApplyType::APPLY_REFUSED),
            2 => ::std::option::Option::Some(FriendOperationApplyType::APPLY_ACCEPTED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FriendOperationApplyType> {
        match str {
            "APPLY_UNKNOWN" => ::std::option::Option::Some(FriendOperationApplyType::APPLY_UNKNOWN),
            "APPLY_REFUSED" => ::std::option::Option::Some(FriendOperationApplyType::APPLY_REFUSED),
            "APPLY_ACCEPTED" => ::std::option::Option::Some(FriendOperationApplyType::APPLY_ACCEPTED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FriendOperationApplyType] = &[
        FriendOperationApplyType::APPLY_UNKNOWN,
        FriendOperationApplyType::APPLY_REFUSED,
        FriendOperationApplyType::APPLY_ACCEPTED,
    ];
}

impl ::protobuf::EnumFull for FriendOperationApplyType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("friendOperationApplyType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FriendOperationApplyType {
    fn default() -> Self {
        FriendOperationApplyType::APPLY_UNKNOWN
    }
}

impl FriendOperationApplyType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FriendOperationApplyType>("friendOperationApplyType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:microchat.GroupOperationType)
pub enum GroupOperationType {
    // @@protoc_insertion_point(enum_value:microchat.GroupOperationType.GROUP_OPERATION_UNKNOWN)
    GROUP_OPERATION_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:microchat.GroupOperationType.GROUP_OPERATION_ADD)
    GROUP_OPERATION_ADD = 1,
    // @@protoc_insertion_point(enum_value:microchat.GroupOperationType.GROUP_OPERATION_DELETE)
    GROUP_OPERATION_DELETE = 2,
    // @@protoc_insertion_point(enum_value:microchat.GroupOperationType.GROUP_OPERATION_MODIFY)
    GROUP_OPERATION_MODIFY = 3,
}

impl ::protobuf::Enum for GroupOperationType {
    const NAME: &'static str = "GroupOperationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GroupOperationType> {
        match value {
            0 => ::std::option::Option::Some(GroupOperationType::GROUP_OPERATION_UNKNOWN),
            1 => ::std::option::Option::Some(GroupOperationType::GROUP_OPERATION_ADD),
            2 => ::std::option::Option::Some(GroupOperationType::GROUP_OPERATION_DELETE),
            3 => ::std::option::Option::Some(GroupOperationType::GROUP_OPERATION_MODIFY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GroupOperationType> {
        match str {
            "GROUP_OPERATION_UNKNOWN" => ::std::option::Option::Some(GroupOperationType::GROUP_OPERATION_UNKNOWN),
            "GROUP_OPERATION_ADD" => ::std::option::Option::Some(GroupOperationType::GROUP_OPERATION_ADD),
            "GROUP_OPERATION_DELETE" => ::std::option::Option::Some(GroupOperationType::GROUP_OPERATION_DELETE),
            "GROUP_OPERATION_MODIFY" => ::std::option::Option::Some(GroupOperationType::GROUP_OPERATION_MODIFY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GroupOperationType] = &[
        GroupOperationType::GROUP_OPERATION_UNKNOWN,
        GroupOperationType::GROUP_OPERATION_ADD,
        GroupOperationType::GROUP_OPERATION_DELETE,
        GroupOperationType::GROUP_OPERATION_MODIFY,
    ];
}

impl ::protobuf::EnumFull for GroupOperationType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GroupOperationType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for GroupOperationType {
    fn default() -> Self {
        GroupOperationType::GROUP_OPERATION_UNKNOWN
    }
}

impl GroupOperationType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GroupOperationType>("GroupOperationType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:microchat.ErrorCode)
pub enum ErrorCode {
    // @@protoc_insertion_point(enum_value:microchat.ErrorCode.ERR_UNKNOWN)
    ERR_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:microchat.ErrorCode.ERR_OK)
    ERR_OK = 1,
    // @@protoc_insertion_point(enum_value:microchat.ErrorCode.ERR_NOT_LOGIN)
    ERR_NOT_LOGIN = 2,
    // @@protoc_insertion_point(enum_value:microchat.ErrorCode.ERR_REG_FAIL)
    ERR_REG_FAIL = 100,
    // @@protoc_insertion_point(enum_value:microchat.ErrorCode.ERR_REG_ALREADY)
    ERR_REG_ALREADY = 101,
    // @@protoc_insertion_point(enum_value:microchat.ErrorCode.ERR_NOT_REG)
    ERR_NOT_REG = 102,
    // @@protoc_insertion_point(enum_value:microchat.ErrorCode.ERR_INVALID_PSW)
    ERR_INVALID_PSW = 103,
    // @@protoc_insertion_point(enum_value:microchat.ErrorCode.ERR_UPD_USERINFO_FAIL)
    ERR_UPD_USERINFO_FAIL = 104,
    // @@protoc_insertion_point(enum_value:microchat.ErrorCode.ERR_MODIFY_PSW_FAIL)
    ERR_MODIFY_PSW_FAIL = 105,
    // @@protoc_insertion_point(enum_value:microchat.ErrorCode.ERR_CRE_GROUP_FAIL)
    ERR_CRE_GROUP_FAIL = 106,
    // @@protoc_insertion_point(enum_value:microchat.ErrorCode.ERR_TOO_OLD_VER)
    ERR_TOO_OLD_VER = 107,
    // @@protoc_insertion_point(enum_value:microchat.ErrorCode.ERR_MODIFY_MARKNAME_FAIL)
    ERR_MODIFY_MARKNAME_FAIL = 108,
    // @@protoc_insertion_point(enum_value:microchat.ErrorCode.ERR_GROUPNAME_EXIST)
    ERR_GROUPNAME_EXIST = 109,
}

impl ::protobuf::Enum for ErrorCode {
    const NAME: &'static str = "ErrorCode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ErrorCode> {
        match value {
            0 => ::std::option::Option::Some(ErrorCode::ERR_UNKNOWN),
            1 => ::std::option::Option::Some(ErrorCode::ERR_OK),
            2 => ::std::option::Option::Some(ErrorCode::ERR_NOT_LOGIN),
            100 => ::std::option::Option::Some(ErrorCode::ERR_REG_FAIL),
            101 => ::std::option::Option::Some(ErrorCode::ERR_REG_ALREADY),
            102 => ::std::option::Option::Some(ErrorCode::ERR_NOT_REG),
            103 => ::std::option::Option::Some(ErrorCode::ERR_INVALID_PSW),
            104 => ::std::option::Option::Some(ErrorCode::ERR_UPD_USERINFO_FAIL),
            105 => ::std::option::Option::Some(ErrorCode::ERR_MODIFY_PSW_FAIL),
            106 => ::std::option::Option::Some(ErrorCode::ERR_CRE_GROUP_FAIL),
            107 => ::std::option::Option::Some(ErrorCode::ERR_TOO_OLD_VER),
            108 => ::std::option::Option::Some(ErrorCode::ERR_MODIFY_MARKNAME_FAIL),
            109 => ::std::option::Option::Some(ErrorCode::ERR_GROUPNAME_EXIST),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ErrorCode> {
        match str {
            "ERR_UNKNOWN" => ::std::option::Option::Some(ErrorCode::ERR_UNKNOWN),
            "ERR_OK" => ::std::option::Option::Some(ErrorCode::ERR_OK),
            "ERR_NOT_LOGIN" => ::std::option::Option::Some(ErrorCode::ERR_NOT_LOGIN),
            "ERR_REG_FAIL" => ::std::option::Option::Some(ErrorCode::ERR_REG_FAIL),
            "ERR_REG_ALREADY" => ::std::option::Option::Some(ErrorCode::ERR_REG_ALREADY),
            "ERR_NOT_REG" => ::std::option::Option::Some(ErrorCode::ERR_NOT_REG),
            "ERR_INVALID_PSW" => ::std::option::Option::Some(ErrorCode::ERR_INVALID_PSW),
            "ERR_UPD_USERINFO_FAIL" => ::std::option::Option::Some(ErrorCode::ERR_UPD_USERINFO_FAIL),
            "ERR_MODIFY_PSW_FAIL" => ::std::option::Option::Some(ErrorCode::ERR_MODIFY_PSW_FAIL),
            "ERR_CRE_GROUP_FAIL" => ::std::option::Option::Some(ErrorCode::ERR_CRE_GROUP_FAIL),
            "ERR_TOO_OLD_VER" => ::std::option::Option::Some(ErrorCode::ERR_TOO_OLD_VER),
            "ERR_MODIFY_MARKNAME_FAIL" => ::std::option::Option::Some(ErrorCode::ERR_MODIFY_MARKNAME_FAIL),
            "ERR_GROUPNAME_EXIST" => ::std::option::Option::Some(ErrorCode::ERR_GROUPNAME_EXIST),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ErrorCode] = &[
        ErrorCode::ERR_UNKNOWN,
        ErrorCode::ERR_OK,
        ErrorCode::ERR_NOT_LOGIN,
        ErrorCode::ERR_REG_FAIL,
        ErrorCode::ERR_REG_ALREADY,
        ErrorCode::ERR_NOT_REG,
        ErrorCode::ERR_INVALID_PSW,
        ErrorCode::ERR_UPD_USERINFO_FAIL,
        ErrorCode::ERR_MODIFY_PSW_FAIL,
        ErrorCode::ERR_CRE_GROUP_FAIL,
        ErrorCode::ERR_TOO_OLD_VER,
        ErrorCode::ERR_MODIFY_MARKNAME_FAIL,
        ErrorCode::ERR_GROUPNAME_EXIST,
    ];
}

impl ::protobuf::EnumFull for ErrorCode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ErrorCode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ErrorCode::ERR_UNKNOWN => 0,
            ErrorCode::ERR_OK => 1,
            ErrorCode::ERR_NOT_LOGIN => 2,
            ErrorCode::ERR_REG_FAIL => 3,
            ErrorCode::ERR_REG_ALREADY => 4,
            ErrorCode::ERR_NOT_REG => 5,
            ErrorCode::ERR_INVALID_PSW => 6,
            ErrorCode::ERR_UPD_USERINFO_FAIL => 7,
            ErrorCode::ERR_MODIFY_PSW_FAIL => 8,
            ErrorCode::ERR_CRE_GROUP_FAIL => 9,
            ErrorCode::ERR_TOO_OLD_VER => 10,
            ErrorCode::ERR_MODIFY_MARKNAME_FAIL => 11,
            ErrorCode::ERR_GROUPNAME_EXIST => 12,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ErrorCode {
    fn default() -> Self {
        ErrorCode::ERR_UNKNOWN
    }
}

impl ErrorCode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ErrorCode>("ErrorCode")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rchatmsg.proto\x12\tmicrochat\"l\n\nOnlineType\x12-\n\x06device\x18\
    \x01\x20\x01(\x0e2\x15.microchat.DeviceTypeR\x06device\x12/\n\x06status\
    \x18\x02\x20\x01(\x0e2\x17.microchat.OnlineStatusR\x06status\"\x98\x01\n\
    \x06Header\x12\x1a\n\x08compress\x18\x01\x20\x01(\x08R\x08compress\x12\
    \x1f\n\x0borigin_size\x18\x02\x20\x01(\x05R\noriginSize\x12#\n\rcompress\
    _size\x18\x03\x20\x01(\x05R\x0ccompressSize\x12\x1f\n\x08reserved\x18\
    \x04\x20\x01(\tH\0R\x08reserved\x88\x01\x01B\x0b\n\t_reserved*\xf1\x02\n\
    \x07MsgType\x12\x0b\n\x07UNKNOWN\x10\0\x12\r\n\tHEARTBEAT\x10\x01\x12\
    \x0c\n\x08REGISTER\x10\x02\x12\t\n\x05LOGIN\x10\x03\x12\x14\n\x10GET_OFR\
    IEND_LIST\x10\x04\x12\r\n\tFIND_USER\x10\x05\x12\x12\n\x0eOPERATE_FRIEND\
    \x10\x06\x12\x16\n\x12USER_STATUS_CHANGE\x10\x07\x12\x14\n\x10UPDATE_USE\
    R_INFO\x10\x08\x12\x13\n\x0fMODIFY_PASSWORD\x10\t\x12\x10\n\x0cCREATE_GR\
    OUP\x10\n\x12\x15\n\x11GET_GROUP_MEMBERS\x10\x0b\x12\x08\n\x04CHAT\x102\
    \x12\x0e\n\nMULTI_CHAT\x103\x12\r\n\tKICK_USER\x104\x12\x12\n\x0eREMOTE_\
    DESKTOP\x105\x12\x14\n\x10UPDATE_TEAM_INFO\x106\x12\x1a\n\x16MODIFY_FRIE\
    ND_MARKNAME\x107\x12\x1d\n\x19MOVE_FRIEND_TO_OTHER_TEAM\x108*M\n\nDevice\
    Type\x12\x0b\n\x07WINDOWS\x10\0\x12\t\n\x05LINUX\x10\x01\x12\x07\n\x03MA\
    C\x10\x02\x12\x0b\n\x07ANDROID\x10\x03\x12\x07\n\x03IOS\x10\x04\x12\x08\
    \n\x04IPAD\x10\x05*B\n\x0cOnlineStatus\x12\x0b\n\x07OFFLINE\x10\0\x12\r\
    \n\tINVISIBLE\x10\x01\x12\x08\n\x04WIFI\x10\x02\x12\x0c\n\x08CELLULAR\
    \x10\x03*\x97\x01\n\x13FriendOperationType\x12\x15\n\x11OPERATION_UNKNOW\
    N\x10\0\x12\x12\n\x0eSEND_ADD_APPLY\x10\x01\x12\x12\n\x0eRECV_ADD_APPLY\
    \x10\x02\x12\x13\n\x0fREPLY_ADD_APPLY\x10\x03\x12\x15\n\x11SEND_DELETE_A\
    PPLY\x10\x04\x12\x15\n\x11RECV_DELETE_APPLY\x10\x05*T\n\x18friendOperati\
    onApplyType\x12\x11\n\rAPPLY_UNKNOWN\x10\0\x12\x11\n\rAPPLY_REFUSED\x10\
    \x01\x12\x12\n\x0eAPPLY_ACCEPTED\x10\x02*\x82\x01\n\x12GroupOperationTyp\
    e\x12\x1b\n\x17GROUP_OPERATION_UNKNOWN\x10\0\x12\x17\n\x13GROUP_OPERATIO\
    N_ADD\x10\x01\x12\x1a\n\x16GROUP_OPERATION_DELETE\x10\x02\x12\x1a\n\x16G\
    ROUP_OPERATION_MODIFY\x10\x03*\xa0\x02\n\tErrorCode\x12\x0f\n\x0bERR_UNK\
    NOWN\x10\0\x12\n\n\x06ERR_OK\x10\x01\x12\x11\n\rERR_NOT_LOGIN\x10\x02\
    \x12\x10\n\x0cERR_REG_FAIL\x10d\x12\x13\n\x0fERR_REG_ALREADY\x10e\x12\
    \x0f\n\x0bERR_NOT_REG\x10f\x12\x13\n\x0fERR_INVALID_PSW\x10g\x12\x19\n\
    \x15ERR_UPD_USERINFO_FAIL\x10h\x12\x17\n\x13ERR_MODIFY_PSW_FAIL\x10i\x12\
    \x16\n\x12ERR_CRE_GROUP_FAIL\x10j\x12\x13\n\x0fERR_TOO_OLD_VER\x10k\x12\
    \x1c\n\x18ERR_MODIFY_MARKNAME_FAIL\x10l\x12\x17\n\x13ERR_GROUPNAME_EXIST\
    \x10mb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(2);
            messages.push(OnlineType::generated_message_descriptor_data());
            messages.push(Header::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(7);
            enums.push(MsgType::generated_enum_descriptor_data());
            enums.push(DeviceType::generated_enum_descriptor_data());
            enums.push(OnlineStatus::generated_enum_descriptor_data());
            enums.push(FriendOperationType::generated_enum_descriptor_data());
            enums.push(FriendOperationApplyType::generated_enum_descriptor_data());
            enums.push(GroupOperationType::generated_enum_descriptor_data());
            enums.push(ErrorCode::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
